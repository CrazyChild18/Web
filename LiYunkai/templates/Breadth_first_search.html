<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Breadth-first Search</title>
		<link href="../static/css/Content.css" type="text/css" rel="stylesheet"/>
	</head>
	<body>

        {% with message = get_flashed_messages() %}
            {% if message %}
                <div class="result" style="color: red">{{ message }}</div>
            {% endif %}
        {% endwith %}

		<a href="{{ url_for('main') }}"><div class="return">Return<br/>Back</div></a>
		<div class="body">
			<!-- 标题部分 -->
			<div class="body_title">Breadth-first Search</div>
			<!-- 代码运行展示部分 -->
			<div class="show">
				<p>(Click Play to run the code to show the sorting process)</p>
				<a href="https://algorithm-visualizer.org/brute-force/breadth-first-search" target="_blank">You can also click here to jump to the demo page</a>
				<video style="width: 100%; height: 700px;" controls>
                    <source src="../static/img/breadth_first_search_video.mp4" type="video/mp4">
                </video>
			</div>
			<!-- 算法讲解部分 -->
			<div class="body_content">
				<div class="content_title">Theory:</div>
				<div class="content_text">
                    <ul>
                        <li>
                            Simply put, BFS starts at the root node and traverses the nodes along the width of
                            the tree (graph). If all nodes are accessed, the algorithm is aborted. BFS is also
                            a blind search. Queue data structure is generally used to assist the implementation
                            of BFS algorithm.
                        </li>
                    </ul>
                </div>
				<div class="content_title">Code (Java):</div>
                    <img src="../static/img/broad_first_search_code.png" style="width: 70%; height: auto;">
                <div class="content_title">Tips：</div>
				<div class="content_text">
                    <ol>
                        <li>First, put the root node into the queue.</li>
                        <li>Take the first node out of the queue and verify that it is a target.<br>
                            <ul>
                                <li>If the target is found, the search is ended and the results returned.</li>
                                <li>Otherwise, it queues all its immediate children that have not yet been validated.</li>
                            </ul>
                        </li>
                        <li>
                            If the queue is empty, the entire graph has been checked -- that is, there are no objects
                            in the graph to be searched. End the search and return "no target found".
                        </li>
                        <li>Repeat step 2.</li>
                    </ol>
				</div>
				<div class="content_title">Complexity:</div>
				<div class="content_text">
                    <ul>
                        <li>Time complexity O(n)</li>
                        <li>In the worst case, s is far away from T, so it needs to traverse the complete graph to
                            find it. However, traversal is not repeated, and traverses all vertices at most, so the
                            complexity is O(n).</li>
                        <li>Space complexity O(n)</li>
                    </ul>
				</div>
				<div class="content_title">Application scenarios:</div>
				<div class="content_text">
                    <ul>
                        <li>
                            Graph structures have played an important role in solving many network-related problems.
                            For example, it is used to determine the best path in the Internet from one node to
                            another (the gateway from one network to another). One modeling method is to use an
                            undirected graph, in which vertices represent network nodes and edges represent
                            connections between nodes. With this model, breadth first search can be used to help
                            determine the minimum number of hops between nodes.
                        </li>
                    </ul>
				</div>
			</div>

            {% if posts %}
                <br><br>
                <hr><hr><br>
                <div class="post_title">Comment Area:</div>
                {% for post in posts %}
		            <div class="post" style="margin-left:30px; color: white">{{ post.author_id }}</div>
		            <div class="post" style="margin-left:30px; color: white">{{ post.create_date }}</div>
		            <div class="post" style="margin-left:30px; border-style:double; color: white" >{{ post.comment }}</div><br><br>
                {% endfor %}
            {% else %}
                <br><br>
                <hr><br>
                <div class="post" style="margin-left:30px; color: white">No post here. You can publish one first.</div><br><br>
            {% endif %}

            <form action="" method="post" novalidate style="width: 100%;">
                {{ form.hidden_tag() }}
                <div class="comment_body" >{{ form.content }}</div>
                <div class="comment_submit">{{ form.submit }}</div>
            </form>

		</div>

		<div class="footing">
			@Yunkai.li
			<br />
			Reference by <a href="https://algorithm-visualizer.org/">https://algorithm-visualizer.org/</a>
		</div>
	</body>
</html>
